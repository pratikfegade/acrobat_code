#[version = "0.0.5"]

type Node {
  NodeCons(Tensor[(1, 512), float32], List[Tensor[(1, 512), float32]]),
}

def @rnn_cell(
  %input: Tensor[(1, 512), float32],
  %state: Tensor[(1, 512), float32],

  %weight: Tensor[(512, 1024), float32],
  %bias: Tensor[(1, 512), float32]
) -> Tensor[(1, 512), float32] {
  let %func = fn(
    %_input: Tensor[(1, 512), float32],
    %_state: Tensor[(1, 512), float32],
    %_weight: Tensor[(512, 1024), float32],
    %_bias: Tensor[(1, 512), float32],
    Primitive = 1
  ) {
    sigmoid(
      %_bias + nn.dense(concatenate((%_input, %_state), axis=1), %_weight, units=512)
    )
  };
  %func(%input, %state, %weight, %bias)
}

def @gru_cell(
  %input: Tensor[(1, 512), float32],
  %state: Tensor[(1, 512), float32],

  %zweight: Tensor[(512, 1024), float32],
  %rweight: Tensor[(512, 1024), float32],
  %hweight: Tensor[(512, 1024), float32],
  %zbias: Tensor[(1, 512), float32],
  %rbias: Tensor[(1, 512), float32],
  %hbias: Tensor[(1, 512), float32]
) -> Tensor[(1, 512), float32] {
  let %rz_func = fn(
    %_input: Tensor[(1, 512), float32],
    %_state: Tensor[(1, 512), float32],
    %_zweight: Tensor[(512, 1024), float32],
    %_zbias: Tensor[(1, 512), float32],
    Primitive=1
  ) -> Tensor[(1, 512), float32] {
    sigmoid(
      %_zbias + nn.dense(concatenate((%_input, %_state), axis=1), %_zweight, units=512)
    )
  };

  let %hp_func = fn(
    %_input: Tensor[(1, 512), float32],
    %_state: Tensor[(1, 512), float32],
    %_hweight: Tensor[(512, 1024), float32],
    %_hbias: Tensor[(1, 512), float32],
    %_r: Tensor[(1, 512), float32],
    Primitive=1
  ) -> Tensor[(1, 512), float32] {
    tanh(
      %_hbias + nn.dense(concatenate((%_input, %_r * %_state), axis=1), %_hweight, units=512)
    )
  };


  let %z = %rz_func(%input, %state, %zweight, %zbias);
  let %r = %rz_func(%input, %state, %rweight, %rbias);
  let %hp = %hp_func(%input, %state, %hweight, %hbias, %r);

  let %fin_func = fn(
    %_z: Tensor[(1, 512), float32],
    %_state: Tensor[(1, 512), float32],
    %_hp: Tensor[(1, 512), float32],
    Primitive=1
  ) -> Tensor[(1, 512), float32] {
    ((1f - %_z) * %_state) + (%_z * %_hp)
  };

  %fin_func(%z, %state, %hp)
}

def @create_edges(
  %num_edges: Tensor[(), int32SS],
  %node_state: Tensor[(1, 512), float32],
  %edge_state: Tensor[(1, 512), float32],

  %edge_rnn_weight: Tensor[(512, 1024), float32],
  %edge_rnn_bias: Tensor[(1, 512), float32]
) -> (List[Tensor[(1, 512), float32]], Tensor[(1, 512), float32]) {
  if (%num_edges <= 0) {
    (Nil, %edge_state)
  } else {
    let %updated_edge_state = @rnn_cell(%node_state, %edge_state,
      %edge_rnn_weight, %edge_rnn_bias);
    let %create_edges_res = @create_edges(%num_edges - 1, %node_state, %updated_edge_state,
      %edge_rnn_weight, %edge_rnn_bias);
    (Cons(%updated_edge_state, %create_edges_res.0), %create_edges_res.1)
  }
}

def @create_nodes(
  %h_state: Tensor[(1, 512), float32],
  %s_state: Tensor[(1, 512), float32],

  %node_ctr: Tensor[(), int32SS],
  %total_num_nodes: Tensor[(), int32SS],

  %node_rnn_zweight: Tensor[(512, 1024), float32],
  %node_rnn_rweight: Tensor[(512, 1024), float32],
  %node_rnn_hweight: Tensor[(512, 1024), float32],
  %node_rnn_zbias: Tensor[(1, 512), float32],
  %node_rnn_rbias: Tensor[(1, 512), float32],
  %node_rnn_hbias: Tensor[(1, 512), float32],

  %node_out_weight: Tensor[(512, 512), float32],
  %node_out_bias: Tensor[(1, 512), float32]

  %edge_rnn_weight: Tensor[(512, 1024), float32],
  %edge_rnn_bias: Tensor[(1, 512), float32]
) -> List[Node] {

  if (%node_ctr < %total_num_nodes) {
    let %num_edges = %node_ctr - 1;
    let %updated_h_state = @gru_cell(
      %h_state, %s_state,
      %node_rnn_zweight, %node_rnn_rweight,
      %node_rnn_hweight, %node_rnn_zbias,
      %node_rnn_rbias, %node_rnn_hbias
    );

    let %node_out_fn = fn(
      %_input: Tensor[(1, 512), float32],
      %_weight: Tensor[(512, 512), float32],
      %_bias: Tensor[(1, 512), float32],
      Primitive = 1
    ) {
      tanh(
        %_bias + nn.dense(%_input, %_weight, units=512)
      )
    };

    let %node_output: Tensor[(1, 512), float32] = %node_out_fn(%updated_h_state, %node_out_weight, %node_out_bias);

    let %create_edges_res = @create_edges(%num_edges, %node_output, %node_output,
      %edge_rnn_weight, %edge_rnn_bias);

    let %tail = @create_nodes(
      %updated_h_state, %create_edges_res.1,
      %node_ctr + 1, %total_num_nodes,
      %node_rnn_zweight, %node_rnn_rweight,
      %node_rnn_hweight, %node_rnn_zbias,
      %node_rnn_rbias, %node_rnn_hbias,
      %node_out_weight, %node_out_bias,
      %edge_rnn_weight, %edge_rnn_bias
    );

    Cons(NodeCons(%create_edges_res.1, %create_edges_res.0), %tail)
  } else {
    Nil
  }
}

def @main(
  %node_rnn_zweight: Tensor[(512, 1024), float32],
  %node_rnn_rweight: Tensor[(512, 1024), float32],
  %node_rnn_hweight: Tensor[(512, 1024), float32],
  %node_rnn_zbias: Tensor[(1, 512), float32],
  %node_rnn_rbias: Tensor[(1, 512), float32],
  %node_rnn_hbias: Tensor[(1, 512), float32],

  %node_out_weight: Tensor[(512, 512), float32],
  %node_out_bias: Tensor[(1, 512), float32]

  %edge_rnn_weight: Tensor[(512, 1024), float32],
  %edge_rnn_bias: Tensor[(1, 512), float32],

  %total_num_nodes: Tensor[(), int32SS],
  %input: Tensor[(1, 512), float32]
) -> List[Node] {
  let %node_state = zeros(shape=[1, 512], dtype="float32");
  @create_nodes(
    %input, %node_state, 0, %total_num_nodes,
    %node_rnn_zweight, %node_rnn_rweight,
    %node_rnn_hweight, %node_rnn_zbias,
    %node_rnn_rbias, %node_rnn_hbias,
    %node_out_weight, %node_out_bias,
    %edge_rnn_weight, %edge_rnn_bias
  )
}
