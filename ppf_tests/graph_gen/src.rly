#[version = "0.0.5"]

type Node {
  NodeCons(Tensor[(1, 256), float32], List[Tensor[(1, 256), float32]]),
}

def @rnn_cell(
  %input: Tensor[(1, 256), float32],
  %state: Tensor[(1, 256), float32],

  %weight: Tensor[(256, 512), float32],
  %bias: Tensor[(1, 256), float32]
) -> Tensor[(1, 256), float32] {
  let %func = fn(
    %_input: Tensor[(1, 256), float32],
    %_state: Tensor[(1, 256), float32],
    %_weight: Tensor[(256, 512), float32],
    %_bias: Tensor[(1, 256), float32],
    Primitive = 1
  ) {
    sigmoid(
      %_bias + nn.dense(concatenate((%_input, %_state), axis=1), %_weight, units=256)
    )
  };
  %func(%input, %state, %weight, %bias)
}

def @gru_cell(
  %input: Tensor[(1, 256), float32],
  %state: Tensor[(1, 256), float32],

  %zweight: Tensor[(256, 512), float32],
  %rweight: Tensor[(256, 512), float32],
  %hweight: Tensor[(256, 512), float32],
  %zbias: Tensor[(1, 256), float32],
  %rbias: Tensor[(1, 256), float32],
  %hbias: Tensor[(1, 256), float32]
) -> Tensor[(1, 256), float32] {
  let %rz_func = fn(
    %_input: Tensor[(1, 256), float32],
    %_state: Tensor[(1, 256), float32],
    %_zweight: Tensor[(256, 512), float32],
    %_zbias: Tensor[(1, 256), float32],
    Primitive=1
  ) -> Tensor[(1, 256), float32] {
    sigmoid(
      %_zbias + nn.dense(concatenate((%_input, %_state), axis=1), %_zweight, units=256)
    )
  };

  let %hp_func = fn(
    %_input: Tensor[(1, 256), float32],
    %_state: Tensor[(1, 256), float32],
    %_hweight: Tensor[(256, 512), float32],
    %_hbias: Tensor[(1, 256), float32],
    %_r: Tensor[(1, 256), float32],
    Primitive=1
  ) -> Tensor[(1, 256), float32] {
    tanh(
      %_hbias + nn.dense(concatenate((%_input, %_r * %_state), axis=1), %_hweight, units=256)
    )
  };


  let %z = %rz_func(%input, %state, %zweight, %zbias);
  let %r = %rz_func(%input, %state, %rweight, %rbias);
  let %hp = %hp_func(%input, %state, %hweight, %hbias, %r);

  let %fin_func = fn(
    %_z: Tensor[(1, 256), float32],
    %_state: Tensor[(1, 256), float32],
    %_hp: Tensor[(1, 256), float32],
    Primitive=1
  ) -> Tensor[(1, 256), float32] {
    ((1f - %_z) * %_state) + (%_z * %_hp)
  };

  %fin_func(%z, %state, %hp)
}

def @create_edges(
  %num_edges: Tensor[(), int32],
  %node_state: Tensor[(1, 256), float32],
  %edge_state: Tensor[(1, 256), float32],

  %edge_rnn_weight: Tensor[(256, 512), float32],
  %edge_rnn_bias: Tensor[(1, 256), float32]
) -> (List[Tensor[(1, 256), float32]], Tensor[(1, 256), float32]) {
  if (%num_edges == 0) {
    (Nil, %edge_state)
  } else {
    let %updated_edge_state = @rnn_cell(%node_state, %edge_state,
      %edge_rnn_weight, %edge_rnn_bias);
    let %create_edges_res = @create_edges(%num_edges - 1, %node_state, %updated_edge_state,
      %edge_rnn_weight, %edge_rnn_bias);
    (Cons(%updated_edge_state, %create_edges_res.0), %create_edges_res.1)
  }
}

def @create_nodes(
  %inputs: List[Tensor[(1, 256), float32]],
  %node_state: Tensor[(1, 256), float32],

  %node_rnn_zweight: Tensor[(256, 512), float32],
  %node_rnn_rweight: Tensor[(256, 512), float32],
  %node_rnn_hweight: Tensor[(256, 512), float32],
  %node_rnn_zbias: Tensor[(1, 256), float32],
  %node_rnn_rbias: Tensor[(1, 256), float32],
  %node_rnn_hbias: Tensor[(1, 256), float32],

  %edge_rnn_weight: Tensor[(256, 512), float32],
  %edge_rnn_bias: Tensor[(1, 256), float32]
) -> List[Node] {
  match (%inputs) {
    Cons(%input, %input_tail) => {
      let %num_edges = random.db_uniform(20, 50, out_shape=[], out_dtype="int32");
      let %updated_node_state = @gru_cell(
        %input, %node_state,
        %node_rnn_zweight, %node_rnn_rweight,
        %node_rnn_hweight, %node_rnn_zbias,
        %node_rnn_rbias, %node_rnn_hbias
      );

      let %create_edges_res = @create_edges(%num_edges, %updated_node_state, %updated_node_state,
        %edge_rnn_weight, %edge_rnn_bias);

      let %tail = @create_nodes(
        %input_tail, %create_edges_res.1,
        %node_rnn_zweight, %node_rnn_rweight,
        %node_rnn_hweight, %node_rnn_zbias,
        %node_rnn_rbias, %node_rnn_hbias,
        %edge_rnn_weight, %edge_rnn_bias
      );

      Cons(NodeCons(%create_edges_res.1, %create_edges_res.0), %tail)
    },
    Nil => {
      Nil
    },
  }
}

def @main(
  %node_rnn_zweight: Tensor[(256, 512), float32],
  %node_rnn_rweight: Tensor[(256, 512), float32],
  %node_rnn_hweight: Tensor[(256, 512), float32],
  %node_rnn_zbias: Tensor[(1, 256), float32],
  %node_rnn_rbias: Tensor[(1, 256), float32],
  %node_rnn_hbias: Tensor[(1, 256), float32],

  %edge_rnn_weight: Tensor[(256, 512), float32],
  %edge_rnn_bias: Tensor[(1, 256), float32],

  %inputs: List[Tensor[(1, 256), float32]]
) -> List[Node] {
  let %node_state = zeros(shape=[1, 256], dtype="float32");
  @create_nodes(
    %inputs, %node_state,
    %node_rnn_zweight, %node_rnn_rweight,
    %node_rnn_hweight, %node_rnn_zbias,
    %node_rnn_rbias, %node_rnn_hbias,
    %edge_rnn_weight, %edge_rnn_bias
  )
}
